<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>HW 6 Ray Tracing</title>
    <style>
        body { 
            background: #111;
            color: #ccc;
            font-family: monospace;
            margin: 0;
            height: 100vh;  
            display: flex;
            flex-direction: column;
        }
        textarea {
            background: #222;
            color: #0f0;
            font: 14px monospace;
            width: 800px;
            height: 600px;
        }
        
        canvas {
            border: 1px solid #444;
            margin: 0 auto;       
        }
        .container {
            display: flex;
            justify-content: center;  
            align-items: center; 
            gap: 20px;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;  
        }

        .editor-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .controls label {
            display: block;
            margin: 5px 0;
        }

        .controls-container {
            width: 100%;
            display: flex;
            justify-content: center;
            margin-top: 20px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            align-items: center; 
            gap: 10px;
        }
    </style>
</head>
<body>

<h2>HW 6 Ray Tracing</h2>
<p></p>

<div class="container">
    <div class="canvas-container">
        <canvas id="glCanvas" width="1200" height="800"></canvas>
    </div>
    <!-- <div class="editor-panel">
         <div>
            <b>Fragment Shader</b><br>
            <textarea id="fsEditor"></textarea>
        </div>
        <div>
            <b>Vertex Shader</b><br>
            <textarea id="vsEditor"></textarea>
        </div>
    </div> -->
</div>

<div class="controls-container">
    <div class="controls">
        <label>
            Max Bounces: <span id="maxBouncesValue">4</span>
            <input type="range" id="maxBouncesSlider" min="4" max="32" step="1" value="4">
        </label>

        <label>
            Ambient Strength: <span id="ambientStrengthValue">0.25</span>
            <input type="range" id="ambientStrengthSlider" min="0" max="1" step="0.01" value="0.25">
        </label>

        <label>
            Sphere Size: <span id="sphereSizeValue">0.50</span>
            <input type="range" id="sphereSizeSlider" min="0.1" max="5.0" step="0.01" value="0.3">
        </label>

        <label>
            Sphere Rotation Radius: <span id="sphereRotRadValue">1.00</span>
            <input type="range" id="sphereRotRadSlider" min="0.1" max="10.0" step="0.01" value="1.0">
        </label>

        <label>
            Sphere Rotation Speed: <span id="sphereRotSpeedValue">1.00</span>
            <input type="range" id="sphereRotSpeedSlider" min="0.1" max="10.0" step="0.01" value="1.0">
        </label>
    </div>
</div>


    


<script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
    in vec2 position;
    void main() {
        gl_Position = vec4(position, 0.0, 1.0);
    }
</script>

<script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;

    //time for animation
    uniform float u_time;
    uniform vec2 u_resolution;
    uniform int u_maxBounces;
    uniform float u_ambientStrength;

    uniform vec3 u_cam_pos;
    uniform float u_yaw;
    uniform float u_pitch;

    uniform float u_sphere_size;
    uniform float u_sphere_rot_rad;
    uniform float u_sphere_rot_speed;

    out vec4 fragColor;

    // Material types
    const int MATERIAL_DIFFUSE = 0;
    const int MATERIAL_REFLECTIVE = 1;
    const int MATERIAL_REFRACTIVE = 2;

    const float eps = 1e-3;

    // Ray structure
    struct Ray {
        vec3 origin;
        vec3 direction;
    };

    // Sphere structure
    struct Sphere {
        vec3 center;
        float radius;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
    };

    // Cube structure
    struct Cube {
        vec3 center;
        vec3 size;
        vec3 color;
        int material;
        float reflectivity;
    };

    // Hit record structure
    struct HitData {
        bool hit;
        float t;
        vec3 point;
        vec3 normal;
        vec3 color;
        int material;
        float reflectivity;
        float refractiveIndex;
        bool frontFace;
    };

    // Scene objects
    const int MAX_SPHERES = 12;
    const int MAX_CUBES = 10;
    const int MAX_LIGHTS = 2;

    Sphere spheres[MAX_SPHERES];
    Sphere lightSphere[MAX_LIGHTS];
    Cube cube;

    vec3 neon(float t) {
        float hue = fract(t * 0.12);
        float shimmer = 0.5 + 0.5 * sin(t * 2.7);
        float plasma = 0.5 + 0.5 * sin(t * 13.0 + sin(t * 3.1));
        float energy = mix(shimmer, plasma, 0.7);
        vec3 base = vec3(
            0.2 + 0.8 * sin(t * 0.8 + 0.0),
            0.4 + 0.6 * sin(t * 0.8 + 2.0),
            0.6 + 0.4 * sin(t * 0.8 + 4.0)
        );
        vec3 color = base * energy;
        return clamp(color, 0.0, 1.0);
    }

    vec3 plasma(vec3 p, float t) {
        float v =
            sin(p.x*3.1 + t*1.2) +
            sin(p.y*4.3 + t*1.7) +
            sin((p.x+p.z)*2.7 + t*0.8) +
            sin(length(p)*3.0 - t*2.0);

        v = v * 0.25 + 0.5;

        return vec3(
            0.5 + 0.5*sin(6.283*(v + 0.0)),
            0.5 + 0.5*sin(6.283*(v + 0.33)),
            0.5 + 0.5*sin(6.283*(v + 0.66))
        );
    }

    // Initialize scene objects
    void initScene(float time) {

        lightSphere[1] = Sphere(
            vec3(sin(u_time*0.5) * 4.0, 0.0, cos(u_time*0.5) * 4.0),
            0.25,
            neon(u_time),
            MATERIAL_DIFFUSE,
            1.0,
            1.0
        );

        lightSphere[0] = Sphere(
            vec3(0.0, 0.0, 0.0),
            0.5,
            plasma(lightSphere[1].center * 0.2, u_time * 0.2),
            MATERIAL_DIFFUSE,
            1.0,
            1.0
        );

        //cube
        cube = Cube(
            vec3(0.0, -2.0, 0.0),
            vec3(10.0, 0.1, 10.0),
            vec3(0.7, 0.7, 0.7),
            MATERIAL_REFLECTIVE,
            0.5
        );

        float a = 1.0 + 0.3 * sin(time*0.6);
        float b = 1.0 + 0.3 * cos(time*0.7);


        for (int i = 0; i < MAX_SPHERES; i++) {
            float j = float(i);
            int type = MATERIAL_REFLECTIVE;
            vec3 color = vec3(0.9, 0.9, 0.9);

            float ref = 1.0;
            float refra = 1.0;

            if (i % 2 == 0) {
                type = MATERIAL_REFRACTIVE;
                color = vec3(0.9, 0.9, 0.9);
                refra = 1.0 + (j / float(MAX_SPHERES));
            }
            spheres[i] = Sphere(
                vec3(
                    u_sphere_rot_rad * a * sin(time * 1.3 * u_sphere_rot_speed + j),
                    u_sphere_rot_rad * 0.3 * sin(time * 2.5 * u_sphere_rot_speed + j * 0.5),
                    u_sphere_rot_rad * b * sin(time * 2.1 * u_sphere_rot_speed + j * 1.2)
                ),
                u_sphere_size,
                color,
                type,
                ref,
                refra
            );
        }
    }

    bool intersectSphere(Ray ray, Sphere sphere, out float t) {
        vec3 oc = ray.origin - sphere.center;
        float a = dot(ray.direction, ray.direction);
        float b = 2.0 * dot(oc, ray.direction);
        float c = dot(oc, oc) - sphere.radius * sphere.radius;
        float delta = b * b - 4.0 * a * c;
        if (delta < 0.0) {
            return false;
        }

        float sqrtDelta = sqrt(delta);
        float t0 = (-b - sqrtDelta) / (2.0 * a);
        float t1 = (-b + sqrtDelta) / (2.0 * a);

        
        float tHit = 1e20;

        if (t0 > eps && t0 < tHit) tHit = t0;
        if (t1 > eps && t1 < tHit) tHit = t1;

        if (tHit < 1e19) {
            t = tHit;
            return true;
        }
        return false;
    }

    bool intersectCube(Ray ray, out float t, out vec3 normal) {
        vec3 tMin = (cube.center - cube.size * 0.5 - ray.origin) / ray.direction;
        vec3 tMax = (cube.center + cube.size * 0.5 - ray.origin) / ray.direction;

        vec3 t1 = min(tMin, tMax);
        vec3 t2 = max(tMin, tMax);

        float tNear = max(max(t1.x, t1.y), t1.z);
        float tFar = min(min(t2.x, t2.y), t2.z);

        if (tNear > tFar || tFar < 0.0) {
            return false;
        }

        t = (tNear > 0.0) ? tNear : tFar;

        vec3 hitPoint = ray.origin + t * ray.direction;
        vec3 localPoint = hitPoint - cube.center;
        vec3 halfSize = cube.size * 0.5;

        if (abs(localPoint.x) > halfSize.x - eps) {
            normal = vec3(sign(localPoint.x), 0.0, 0.0);
        } else if (abs(localPoint.y) > halfSize.y - eps) {
            normal = vec3(0.0, sign(localPoint.y), 0.0);
        } else {
            normal = vec3(0.0, 0.0, sign(localPoint.z));
        }

        return true;
    }

    // Trace objects in the scene for intersections
    HitData traceScene(Ray ray, bool includeLightSphere) {
        HitData closest;
        closest.hit = false;
        closest.t = 1e10;

        // Light sphere intersection
        if (includeLightSphere) {

            for (int i = 0; i < 2; i++) {
                float t;
                Sphere current_sphere = lightSphere[i];
                if (intersectSphere(ray, current_sphere, t)) {
                    if (t < closest.t) {
                        closest.hit = true;
                        closest.t = t;
                        closest.point = ray.origin + t * ray.direction;
                        closest.normal = normalize(closest.point - current_sphere.center);
                        closest.color = current_sphere.color;
                        closest.material = current_sphere.material;
                        closest.reflectivity = current_sphere.reflectivity;
                        closest.refractiveIndex = current_sphere.refractiveIndex;
                        closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                    }
                }
            }
            
        }

        // Cube intersection
        float cube_t;
        vec3 cubeNormal;
        if (intersectCube(ray, cube_t, cubeNormal)) {
            if (cube_t < closest.t) {
                closest.hit = true;
                closest.t = cube_t;
                closest.point = ray.origin + cube_t * ray.direction;
                closest.normal = cubeNormal;
                closest.color = cube.color;
                closest.material = cube.material;
                closest.reflectivity = cube.reflectivity;
                closest.refractiveIndex = 1.0;
                closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
            }
        }

        // Sphere intersections
        for (int i = 0; i < MAX_SPHERES; i++) {
            float t;
            if (intersectSphere(ray, spheres[i], t)) {
                if (t < closest.t) {
                    closest.hit = true;
                    closest.t = t;
                    closest.point = ray.origin + t * ray.direction;
                    closest.normal = normalize(closest.point - spheres[i].center);
                    closest.color = spheres[i].color;
                    closest.material = spheres[i].material;
                    closest.reflectivity = spheres[i].reflectivity;
                    closest.refractiveIndex = spheres[i].refractiveIndex;
                    closest.frontFace = dot(ray.direction, closest.normal) < 0.0;
                }
            }
        }
        return closest;
    }

    // refraction
    vec3 refraction(vec3 I, vec3 N, float eta) {
        float cosi = clamp(dot(-I, N), -1.0, 1.0);
        float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
        if (k < 0.0) {
            return reflect(I, N);
        }
        return eta * I + (eta * cosi - sqrt(k)) * N;
    }

    // Schlick approximation
    float schlick(float cosine, float ref_idx) {
        float f0 = (1.0 - ref_idx) / (1.0 + ref_idx);
        f0 = f0 * f0;
        float ftheta = f0 +(1.0 - f0) * pow((1.0 - cosine), 5.0);
        return ftheta;
    }

    vec3 trace(Ray ray, int maxDepth) {
        vec3 color = vec3(0.0);

        //attenuation is optional
        vec3 attenuation = vec3(1.0);

        for (int depth = 0; depth < 64; depth++) {
            if (depth >= maxDepth) break;

            HitData lightHit = traceScene(ray, true);
            if (lightHit.hit && lightHit.material == MATERIAL_DIFFUSE) {
                color += attenuation * lightHit.color;
                break;
            }

            HitData hit = traceScene(ray, false);

            if (!hit.hit) {
                vec3 direction = normalize(ray.direction);
                float t = 0.5 * (direction.y + 1.0);
                vec3 background_color = mix(vec3(0.7, 0.8, 1.0), vec3(0.1, 0.1, 0.2), t);
                color += attenuation * background_color;
                break;
            }

            // loop through several lights

            vec3 total_diffuse = vec3(0.0);
            vec3 total_specular = vec3(0.0);

            for (int i = 0; i < 2; i++) {

                Sphere current_sphere = lightSphere[i];

                vec3 light_pos = current_sphere.center;
                vec3 light_dir = normalize(light_pos - hit.point);
                float light_distance = length(light_pos - hit.point);

                // shadow ray calculations
                Ray shadow_ray = Ray(hit.point + light_dir * eps, light_dir);
                HitData shadow_hit = traceScene(shadow_ray, false);

                float shadow = (!shadow_hit.hit || shadow_hit.t > light_distance) ? 1.0 : 0.0;

                // diffuse calculations
                float diff = max(dot(hit.normal, light_dir), 0.0);
                diff *= shadow;
                total_diffuse += diff * current_sphere.color;

                // specular calculations
                vec3 view_direction = normalize(-ray.direction);
                vec3 half_direction = normalize(light_dir + view_direction);
                float spec = pow(max(dot(hit.normal, half_direction), 0.0), 32.0);
                spec *= shadow;
                total_specular += spec * current_sphere.color;

            }

            if (hit.material == MATERIAL_DIFFUSE) {
                vec3 direct_light = total_diffuse * hit.color + total_specular;
                vec3 ambient_light = u_ambientStrength * hit.color;
            
                vec3 lighting = direct_light + ambient_light;
                color += attenuation * lighting;
                break;

            } else if (hit.material == MATERIAL_REFRACTIVE) {
                
                vec3 unit_direction = normalize(ray.direction);
                vec3 n = hit.normal;

                float etai = 1.0;
                float etat = hit.refractiveIndex;

                if (!hit.frontFace) {
                    n = -n;
                    float tmp = etai;
                    etai = etat;
                    etat = tmp;
                }

                float eta = etai / etat;
                float costheta = clamp(dot(-unit_direction, n), 0.0, 1.0);
                float sintheta = sqrt(max(0.0, 1.0 - costheta * costheta));

                float schlick_value = schlick(costheta, eta);

                vec3 direction;

                if (schlick_value > 0.5) {
                    direction = reflect(unit_direction, n);
                } else {
                    direction = refraction(unit_direction, n, eta);
                    if (length(direction) < eps) {
                        direction = reflect(unit_direction, n);
                    }
                }

                ray = Ray(hit.point + direction * eps, direction);
                attenuation *= hit.color;

            } else {
                float reflect_val = clamp(hit.reflectivity, 0.0, 1.0);
                vec3 direct_light = total_diffuse * hit.color + total_specular;
                vec3 ambient_light = u_ambientStrength * hit.color;
                vec3 local_lighting = (1.0 - reflect_val) * (direct_light + ambient_light);
                color += attenuation * local_lighting;

                attenuation *= hit.reflectivity;
                ray = Ray(hit.point + hit.normal * eps, reflect(ray.direction, hit.normal));
            }

            if (length(attenuation) < 0.01) break;
        }

        return color;
    }

    void main() {
        initScene(u_time);

        vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;

        vec3 origin = u_cam_pos;
        vec3 direction = normalize(vec3(uv, -1.5));

        float cos_yaw = cos(u_yaw);
        float sin_yaw = sin(u_yaw);
        float cos_pitch = cos(u_pitch);
        float sin_pitch = sin(u_pitch);

        mat3 rot_yaw_y = mat3(
            cos_yaw, 0.0, -sin_yaw,
            0.0,    1.0,  0.0,
            sin_yaw, 0.0,  cos_yaw
        );

        mat3 rot_pitch_x = mat3(
            1.0,     0.0,      0.0,
            0.0, cos_pitch, -sin_pitch,
            0.0, sin_pitch,  cos_pitch
        );

        direction = rot_yaw_y * (rot_pitch_x * direction);

        Ray ray = Ray(origin, direction);
        vec3 color = trace(ray, u_maxBounces);

        color = pow(color, vec3(1.0 / 2.2));

        fragColor = vec4(color, 1.0);
    }
</script>

<script>
    (function() {
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl2');

        if (!gl) {
            alert('WebGL 2 not supported in this browser');
            throw new Error('WebGL 2 not supported');
        }

        // const vsEditor = document.getElementById('vsEditor');
        // const fsEditor = document.getElementById('fsEditor');

        const vertexShaderSource = document.getElementById('vertex-shader').textContent;
        const fragmentShaderSource = document.getElementById('fragment-shader').textContent;

        // // Initialize editors with shader source
        // vsEditor.value = vertexShaderSource;
        // fsEditor.value = fragmentShaderSource;

        let program, positionLocation, resolutionLocation, timeLocation, maxBouncesLocation, ambientStrengthLocation;
        let vao, positionBuffer;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw new Error(gl.getShaderInfoLog(shader));
            }

            return shader;
        }

        function createProgram(gl, vsSource, fsSource) {
            const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);

            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                throw new Error(gl.getProgramInfoLog(prog));
            }

            return prog;
        }

        const positions = new Float32Array([
            -1, -1,
            1, -1,
            -1, 1,
            1, 1
        ]);

        // Initialize buffers
        function initBuffers() {
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            vao = gl.createVertexArray();
            gl.bindVertexArray(vao);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
        }

        function initShaderProgram() {
            try {
                program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
                gl.useProgram(program);
                positionLocation = gl.getAttribLocation(program, 'position');
                resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
                timeLocation = gl.getUniformLocation(program, 'u_time');
                maxBouncesLocation = gl.getUniformLocation(program, 'u_maxBounces');
                ambientStrengthLocation = gl.getUniformLocation(program, 'u_ambientStrength');
                
                initBuffers();
            } catch (e) {
                console.error(e);
            }
        }

        initShaderProgram();

        // // Hot compile when any input in the playground text area
        // vsEditor.onkeyup = initShaderProgram;
        // fsEditor.onkeyup = initShaderProgram;

        let maxBounces = 4;
        let ambientStrength = 0.25;
        let sphere_size = 0.3;
        let sphere_rot_rad = 3.0;
        let sphere_rot_speed = 1.0;

        // UI Controls
        const maxBouncesSlider = document.getElementById("maxBouncesSlider");
        const ambientStrengthSlider = document.getElementById("ambientStrengthSlider");

        const maxBouncesValue = document.getElementById("maxBouncesValue");
        const ambientStrengthValue = document.getElementById("ambientStrengthValue");

        const sphereSizeSlider = document.getElementById("sphereSizeSlider");
        const sphereRotRadSlider = document.getElementById("sphereRotRadSlider");
        const sphereRotSpeedSlider = document.getElementById("sphereRotSpeedSlider");

        const sphereSizeValue = document.getElementById("sphereSizeValue");
        const sphereRotRadValue = document.getElementById("sphereRotRadValue");
        const sphereRotSpeedValue = document.getElementById("sphereRotSpeedValue");


        maxBouncesSlider.oninput = () => {
            maxBounces = parseInt(maxBouncesSlider.value);
            maxBouncesValue.textContent = maxBounces;
        };

        ambientStrengthSlider.oninput = () => {
            ambientStrength = parseFloat(ambientStrengthSlider.value);
            ambientStrengthValue.textContent = ambientStrength.toFixed(2);
        };

        sphereSizeSlider.oninput = () => {
            sphere_size = parseFloat(sphereSizeSlider.value);
            sphereSizeValue.textContent = sphere_size.toFixed(2);
        };

        sphereRotRadSlider.oninput = () => {
            sphere_rot_rad = parseFloat(sphereRotRadSlider.value);
            sphereRotRadValue.textContent = sphere_rot_rad.toFixed(2);
        };

        sphereRotSpeedSlider.oninput = () => {
            sphere_rot_speed = parseFloat(sphereRotSpeedSlider.value);
            sphereRotSpeedValue.textContent = sphere_rot_speed.toFixed(2);
        };

        // Camera movement
        let cam_pos = {
            x: 0.0,
            y: 5.0,
            z: 10.0 
        };
        let yaw = 0.0;
        let pitch = 0.5;

        let zoomSpeed = 1.0;

        canvas.addEventListener("wheel", e => {
            const dir = {
                x: Math.sin(yaw) * Math.cos(pitch),
                y: Math.sin(pitch),
                z: Math.cos(yaw) * Math.cos(pitch)
            };

            const delta = e.deltaY * 0.01 * zoomSpeed;

            cam_pos.x += dir.x * delta;
            cam_pos.y += dir.y * delta;
            cam_pos.z += dir.z * delta;
        });

        const keys = {};
        window.addEventListener("keydown", e => keys[e.key] = true);
        window.addEventListener("keyup", e => keys[e.key] = false);

        // look
        let dragging = false;
        let last_x = 0;
        let last_y = 0;

        const mouse_sense = 0.002;

        canvas.addEventListener("mousedown", e => {
            dragging = true;
            last_x = e.clientX;
            last_y = e.clientY;
        });

        window.addEventListener("mouseup", () => dragging = false);

        window.addEventListener("mousemove", e => {
            if (!dragging) return;

            const dx = e.clientX - last_x;
            const dy = e.clientY - last_y;

            last_x = e.clientX;
            last_y = e.clientY;

            yaw   += dx * mouse_sense;
            pitch -= dy * mouse_sense;

            const max_pitch = Math.PI / 2 - 0.01;
            pitch = Math.max(-max_pitch, Math.min(max_pitch, pitch));
        });

        let cam_pos_location, yaw_location, pitch_location;
        
        cam_pos_location = gl.getUniformLocation(program, "u_cam_pos");
        yaw_location = gl.getUniformLocation(program, "u_yaw");
        pitch_location = gl.getUniformLocation(program, "u_pitch");

        sphere_size_loc = gl.getUniformLocation(program, "u_sphere_size");
        sphere_rot_rad_loc = gl.getUniformLocation(program, "u_sphere_rot_rad");
        sphere_rot_speed_loc = gl.getUniformLocation(program, "u_sphere_rot_speed");

        let startTime = Date.now();
        function render() {
            const time = (Date.now() - startTime) / 1000.0;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.bindVertexArray(vao);

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, time);
            gl.uniform1i(maxBouncesLocation, maxBounces);
            gl.uniform1f(ambientStrengthLocation, ambientStrength);
            gl.uniform3f(cam_pos_location, cam_pos.x, cam_pos.y, cam_pos.z);
            gl.uniform1f(yaw_location, yaw);
            gl.uniform1f(pitch_location, pitch);
            gl.uniform1f(sphere_size_loc, sphere_size);
            gl.uniform1f(sphere_rot_rad_loc, sphere_rot_rad);
            gl.uniform1f(sphere_rot_speed_loc, sphere_rot_speed);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    })();
</script>

</body>
</html>