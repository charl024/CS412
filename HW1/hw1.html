<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW1</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }
  </style>
</head>

<body>
  <h2>WebGL Test</h2>
  <p>Edit vertex and fragment shaders on the left, and you can see the result on the right instantly. <br>
    Please copy your edits to the source code if you want to save them, as the playground doesn't save them to the file.
  </p>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vsEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fsEditor"></textarea>
      </div>
    </div>

    <div>
      <canvas id="glcanvas" width="600" height="600"></canvas>
    </div>
  </div>

  <!-- Vertex Shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
  in vec3 aPosition;
  in vec3 aColor;
  
  uniform vec2 uMouse;
  uniform float uTime; //time in sec
  out vec3 vColor;

  mat2 rotation(float angle) {
    mat2 rotation_mat = mat2(
      cos(angle), -sin(angle), 
      sin(angle), cos(angle));
    return rotation_mat;
  }

  mat2 scaling(float sx, float sy) {
    mat2 scaling_mat = mat2(
      sx , 0.0,
      0.0, sy);
    return scaling_mat;
  }

  void main() {
    // multiplying uTime by a constant speeds up rotation
    float angle = uTime;

    // scaling values depend on sin(angle), and a minimum scale is added to prevent from shrinking too much
    float minimumScale = 0.1;
    float sx = 0.1 * sin(angle) + 0.1 + minimumScale;
    float sy = 0.1 * sin(angle) + 0.1 + minimumScale;

    // get x and y location of triangle
    vec2 position = vec2(aPosition.xy);
    
    // applies scaling and rotation to triangle
    position = scaling(sx, sy) * position;
    position = rotation(angle) * position;

    // move the triangle to mouse cursor position

    float mdist = sqrt((uMouse.x - position.x)*(uMouse.x - position.x) + (uMouse.y - position.y)*(uMouse.y - position.y));

    if (mdist > 2.0) {
      position = vec2(position.x - 0.1, position.y - 0.1);
    }

    // apply position
    gl_Position = vec4(position.xy, 0.0, 1.0);

    // have color change dependong on mouse cursor position and uTime
    float xColor = sin(angle) * aColor.x + 0.5;
    float yColor = uTime*0.2 *aColor.y + 0.5;
    float zColor = uTime*0.2 * aColor.z + 0.5;

    // apply color
    vec3 newColor = vec3(xColor, yColor, zColor);
    vColor = newColor;
  }
  </script>

  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
  precision mediump float;
  in vec3 vColor;

  out vec4 fragColor;

  void main() {
    fragColor = vec4(vColor, 1.0);
  }
  </script>

  <script src="triangle.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }


    // --- WebGL init ---
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");

    const vsEditor = document.getElementById("vsEditor");
    const fsEditor = document.getElementById("fsEditor");
    vsEditor.value = document.getElementById("vertex-shader").textContent;
    fsEditor.value = document.getElementById("fragment-shader").textContent;

    let program, posLoc, colorLoc, timeLoc, mouseLoc;
    let posBuffer, colorBuffer;
    let mouseX = 0.0;
    let mouseY = 0.0;

    // --- Buffers ---
    function initBuffers() {
      posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

      colorBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
    }

    initBuffers();

    function initShaderProgram() {
      try {
        program = createProgram(gl, vsEditor.value, fsEditor.value);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        mouseLoc = gl.getUniformLocation(program, "uMouse");
        
      } catch (e) { console.error(e); }
    }

    initShaderProgram();

    //hot compile when any input in the playground text area
    vsEditor.onkeyup = initShaderProgram;
    fsEditor.onkeyup = initShaderProgram;

    // add mouse events
    function mouseInit() {
      canvas.addEventListener("mousemove", (e) =>{
          const area = canvas.getBoundingClientRect();
          mouseX = ((e.clientX - area.left)/area.width) * 2.0 - 1.0;
          mouseY = ((area.bottom - e.clientY)/area.height) * 2.0 - 1.0;
      });
    }

    mouseInit();

    let startTime = Date.now();
    function render() {
      //clear the canvas
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      gl.enable(gl.DEPTH_TEST);

      // Position buffer binding
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      // Color buffer binding
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

      //delta time in ms
      let deltaTime = Date.now() - startTime;
      //set time in seconds
      gl.uniform1f(timeLoc, deltaTime/1000.0);
      // set mouseLocation
      gl.uniform2f(mouseLoc, mouseX, mouseY);

      // Draw content
      gl.drawArrays(gl.TRIANGLES, 0, 3);
    }

    // Initialize when page loads
    window.onload = function () {
      setInterval(render, 30);
    };
  </script>
</body>

</html>
