<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW2</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }
  </style>
</head>

<body>
  <h2>Interactive Controls & Geometric Primitives</h2>
  <p>Edit vertex and fragment shaders on the left to get the result instantly.<br>
  Use mouse to drag and rotate the cube. <br>
Use arrow keys and w, s keys to move the camera.<br>
Save your code to source file if you want to save it.<br>
Press F12 to see the console for debugging.</p>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
  <canvas id="glcanvas" width="400" height="400"></canvas>
  <div id="shapeButtons" style="text-align: center; margin-top: 10px;">
    <button id="cubeBtn">Cube</button>
    <button id="pyramidBtn">Pyramid</button>
    <button id="sphereBtn">Sphere</button>
    <button id="deleteBtn" style="color: #f55;">Delete</button>
    <button id="clearBtn" style="color: #faa;">Clear All</button>
  </div>
</div>
  </div>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;

uniform float uTime; //time in sec
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;
uniform vec3 uMotionSet;
uniform float uMotionChange;

out vec3 vColor;

void main() {
  gl_Position = uProjectionMatrix * uModelViewMatrix * uModelTransformationMatrix * vec4(aPosition, 1.0);
  vColor = sin(aColor) * 0.5 + 0.5;
}
</script>
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
in vec3 vColor;

out vec4 fragColor;

void main() {
  fragColor = vec4(vColor,1.0);
}
</script>

  <script src="primitives.js"></script>
<script src="transformations.js"></script>

<script type="module">
  import { Renderer } from './renderer.js';

  let renderer, gl, program, posLoc, colorLoc, uMVM, uPM, uMTM, timeLoc;
  let vbo, nbo, ibo;
  let currentShapes = [];

  let u_steps = 100;
  let v_steps = 100;
  let r = 1;

  const canvas = document.getElementById("glcanvas");

  window.onload = function () {
    renderer = new Renderer();
    gl = renderer.gl;
    program = renderer.program;

    posLoc = renderer.attribs.aPosition;
    colorLoc = renderer.attribs.aColor;
    timeLoc = renderer.uniforms.uTime;
    uMVM = renderer.uniforms.uModelViewMatrix;
    uPM = renderer.uniforms.uProjectionMatrix;
    uMTM = renderer.uniforms.uModelTransformationMatrix;

    document.getElementById("cubeBtn").addEventListener("click", () => addShape("cube"));
    document.getElementById("pyramidBtn").addEventListener("click", () => addShape("pyramid"));
    document.getElementById("sphereBtn").addEventListener("click", () => addShape("sphere"));
    document.getElementById("deleteBtn").addEventListener("click", () => deleteLastShape());
    document.getElementById("clearBtn").addEventListener("click", () => currentShapes = []);

    setInterval(render, 30);
  };


  function addShape(shapeType) {
    let shape = {};

    switch (shapeType) {
      case 'cube':
        shape.vertices = cube_vertices;
        shape.indices = cube_indices;
        shape.colors = cube_colors;
        break;

      case 'pyramid':
        shape.vertices = pyramid_vertices;
        shape.indices = pyramid_indices;
        shape.colors = pyramid_colors;
        break;

      case 'sphere': {
        const { sphere_vertices, sphere_indices } = sphere(u_steps, v_steps, 1);
        shape.vertices = sphere_vertices;
        shape.indices = sphere_indices;
        shape.colors = sphere_colors(sphere_vertices.length / 3);
        break;
      }

      default:
        return;
    }

    let s = 0.5 + Math.random() * 1.5;
    shape.modelMatrix = mat4Identity();
    shape.modelMatrix = mat4Scale(shape.modelMatrix, [s, s, s]);
    shape.modelMatrix = mat4Translate(shape.modelMatrix, [
      (Math.random() - 0.5) * 6,
      (Math.random() - 0.5) * 4,
      (Math.random() - 0.5) * 4,
    ]);

    shape.timeOffset = Math.random() * 10.0;
    shape.timeSpeed = 0.5 + Math.random() * 1.5;
    shape.motionSet = [
      (Math.random() - 0.5) * 2.0,
      (Math.random() - 0.5) * 2.0,
      (Math.random() - 0.5) * 2.0,
    ];
    shape.motionChange = 0.3 + Math.random() * 0.5;

    currentShapes.push(shape);
  }

  function deleteLastShape() {
    if (currentShapes.length > 0) currentShapes.pop();
  }

  function initBuffers(vertices, indices, colors) {
    vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

    nbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

    ibo = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
  }

  let mouseDown = false, lastX, lastY, cubeRotX = 0, cubeRotY = 0;
  let camX = 0, camY = 0, camZ = -6;

  canvas.addEventListener("mousedown", (e) => {
    mouseDown = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  canvas.addEventListener("mouseup", () => (mouseDown = false));
  canvas.addEventListener("mousemove", (e) => {
    if (!mouseDown) return;
    let dx = e.clientX - lastX;
    let dy = e.clientY - lastY;
    cubeRotY += dx * 0.01;
    cubeRotX += dy * 0.01;
    lastX = e.clientX;
    lastY = e.clientY;
  });

  document.addEventListener("keydown", (e) => {
    const step = 0.2;
    switch (e.key) {
      case "ArrowUp": camY -= step; break;
      case "ArrowDown": camY += step; break;
      case "ArrowLeft": camX += step; break;
      case "ArrowRight": camX -= step; break;
      case "w": camZ += step; break;
      case "s": camZ -= step; break;
    }
  });

  let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
  let f = 1 / Math.tan(fov / 2);
  let proj = new Float32Array([
    f / aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (zFar + zNear) / (zNear - zFar), -1,
    0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
  ]);

  let startTime = Date.now();

  function render() {
    gl.enable(gl.DEPTH_TEST);
    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    let cx = Math.cos(cubeRotY), sx = Math.sin(cubeRotY);
    let cy = Math.cos(cubeRotX), sy = Math.sin(cubeRotX);
    let rotX = [1, 0, 0, 0, 0, cy, sy, 0, 0, -sy, cy, 0, 0, 0, 0, 1];
    let rotY = [cx, 0, -sx, 0, 0, 1, 0, 0, sx, 0, cx, 0, 0, 0, 0, 1];
    let cubeRotation = multiplyMat4(rotY, rotX);

    let modelViewMatrix = mat4Identity();
    modelViewMatrix = mat4Translate(modelViewMatrix, [camX, camY, camZ]);

    let deltaTime = Date.now() - startTime;

    gl.uniformMatrix4fv(uPM, false, proj);
    gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);

    for (const shape of currentShapes) {
      gl.uniform1f(timeLoc, (deltaTime / 1000.0) * shape.timeSpeed + shape.timeOffset);

      const motionSetLoc = gl.getUniformLocation(program, "uMotionSet");
      const motionChangeLoc = gl.getUniformLocation(program, "uMotionChange");
      gl.uniform3fv(motionSetLoc, shape.motionSet);
      gl.uniform1f(motionChangeLoc, shape.motionChange);

      const modelTransformationMatrix = multiplyMat4(cubeRotation, shape.modelMatrix);
      gl.uniformMatrix4fv(uMTM, false, modelTransformationMatrix);

      initBuffers(shape.vertices, shape.indices, shape.colors);

      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.enableVertexAttribArray(posLoc);
      gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
      gl.enableVertexAttribArray(colorLoc);
      gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.drawElements(gl.TRIANGLES, shape.indices.length, gl.UNSIGNED_SHORT, 0);
    }
  }
</script>

  
</body>

</html>