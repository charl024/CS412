<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>UNM CS 412/512 HW2</title>
  <style>
    body {
      background: #111;
      color: #ccc;
      font-family: monospace;
    }

    textarea {
      background: #222;
      color: #0f0;
      font: 14px monospace;
      width: 400px;
      height: 250px;
    }

    canvas {
      border: 1px solid #444;
    }
  </style>
</head>

<body>
  <h2>Interactive Controls & Geometric Primitives</h2>
  <p>Edit vertex and fragment shaders on the left to get the result instantly.<br>
  Use mouse to drag and rotate the cube. <br>
Use arrow keys and w, s keys to move the camera.<br>
Save your code to source file if you want to save it.<br>
Press F12 to see the console for debugging.</p>

  <div style="display: flex; gap: 10px; align-items: flex-start;">
    <div style="display: flex; flex-direction: column; gap: 10px;">
      <div>
        <b>Vertex Shader</b><br>
        <textarea id="vertEditor"></textarea>
      </div>
      <div>
        <b>Fragment Shader</b><br>
        <textarea id="fragEditor"></textarea>
      </div>
    </div>
    <div>
  <canvas id="glcanvas" width="400" height="400"></canvas>
  <div id="shapeButtons" style="text-align: center; margin-top: 10px;">
    <button id="cubeBtn">Cube</button>
    <button id="pyramidBtn">Pyramid</button>
    <button id="sphereBtn">Sphere</button>
    <button id="deleteBtn" style="color: #f55;">Delete</button>
    <button id="clearBtn" style="color: #faa;">Clear All</button>
  </div>
</div>
  </div>

  <!-- Vertex shader -->
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
in vec3 aPosition;
in vec3 aColor;

uniform float uTime; //time in sec
uniform mat4 uModelViewMatrix;
uniform mat4 uProjectionMatrix;
uniform mat4 uModelTransformationMatrix;
uniform vec3 uMotionSet;
uniform float uMotionChange;

out vec3 vColor;

mat4 rotationY(float cx, float sx) {
  mat4 roty = mat4(
    cx, 0.0, -sx, 0.0,
    0.0, 1.0, 0.0, 0.0,
    sx, 0.0,  cx, 0.0,
    0.0, 0.0, 0.0, 1.0
  );

  return roty;
}

mat4 shear(float shxy, float shxz, float shyz, float shyx, float shzx, float shzy) {
  mat4 shear_res = mat4(
    1.0, shxy, shxz, 0.0,
    shyx, 1.0,  shyz, 0.0,
    shzx, shzy,  1.0,  0.0,
    0.0, 0.0,  0.0,  1.0
  );
  return shear_res;
}

void main() {
  float angle = uTime;
  float cx = cos(angle);
  float sx = sin(angle);

  vec3 offset = sin(uTime) * uMotionChange * uMotionSet;
  vec3 new_pos = aPosition + offset;

  float scale = abs(sin(uTime)) * 1.4 + 1.0;

  float shxy = sin(uTime * 0.3) * 0.5;
  float shxz = cos(uTime * 0.5) * 0.3;
  float shyz = sin(uTime * 0.7) * 0.4;
  mat4 shear_mat = shear(shxy, shxz, shyz, 0.0, 0.0, 0.0);
  mat4 rot_mat = rotationY(cx, sx);

  vec4 rotated_pos = rot_mat * shear_mat * vec4(new_pos, scale);

  gl_Position = uProjectionMatrix * uModelViewMatrix * uModelTransformationMatrix * rotated_pos;
  vColor = sin(aColor) * 0.5 + 0.5;
}
</script>
  <!-- Fragment Shader -->
  <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
precision mediump float;
in vec3 vColor;

out vec4 fragColor;

void main() {
  fragColor = vec4(vColor,1.0);
}
</script>

  <script src="primitives.js"></script>
  <script src="transformations.js"></script>

  <script>
    function createShader(gl, type, source) {
      let shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(shader));
      }
      return shader;
    }

    function createProgram(gl, vsSource, fsSource) {
      let vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
      let fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
      let prog = gl.createProgram();
      gl.attachShader(prog, vs);
      gl.attachShader(prog, fs);
      gl.linkProgram(prog);
      if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(prog));
      }
      return prog;
    }

    // WebGL setup
    const canvas = document.getElementById("glcanvas");
    const gl = canvas.getContext("webgl2");
    if (!gl) alert("WebGL2 not supported");

    let vertEditor = document.getElementById("vertEditor");
    let fragEditor = document.getElementById("fragEditor");
    vertEditor.value = document.getElementById("vertex-shader").textContent;
    fragEditor.value = document.getElementById("fragment-shader").textContent;

    let program, posLoc, colorLoc, uMVM, uPM, uMTM;
    let vbo, nbo, ibo;

    let currentShapes = [];

    let u_steps = 100; 
    let v_steps = 100;
    let r = 1;

    // obtain sphere data
    const {sphere_vertices, sphere_indices} = sphere(u_steps, v_steps, 1);
    let sphere_col = sphere_colors(sphere_vertices.length/3.0);

    function addShape(shapeType) {
      let shape = {};
      
      switch (shapeType) {
        case 'cube':
          shape.vertices = cube_vertices;
          shape.indices = cube_indices;
          shape.colors = cube_colors;
          break;
        case 'pyramid':
          shape.vertices = pyramid_vertices;
          shape.indices = pyramid_indices;
          shape.colors = pyramid_colors;
          break;
        case 'sphere':
          const {sphere_vertices, sphere_indices} = sphere(u_steps, v_steps, 1);
          shape.vertices = sphere_vertices;
          shape.indices = sphere_indices;
          shape.colors = sphere_colors(sphere_vertices.length / 3);
          break;
        default:
      }

      // spawn shape somewhere, randomly with a random size
      let s = 0.5 + Math.random() * 1.5;
      shape.modelMatrix = mat4Identity();
      shape.modelMatrix = mat4Scale(shape.modelMatrix, [s, s, s]);
      shape.modelMatrix = mat4Translate(shape.modelMatrix, [
        (Math.random() - 0.5) * 6,
        (Math.random() - 0.5) * 4,
        (Math.random() - 0.5) * 4
      ]);

      shape.timeOffset = Math.random() * 10.0;
      shape.timeSpeed = 0.5 + Math.random() * 1.5;

      shape.motionSet = [
        (Math.random() - 0.5) * 2.0,
        (Math.random() - 0.5) * 2.0,
        (Math.random() - 0.5) * 2.0
      ];
      shape.motionChange = 0.3 + Math.random() * 0.5;


      currentShapes.push(shape)
    }

    function deleteLastShape() {
      if (currentShapes.length > 0) {
        currentShapes.pop();
      }
    }


    // Buffers
    function initBuffers(vertices, indices, colors) {
      vbo = gl.createBuffer();  
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

      nbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);

      ibo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    }

    function initShaderProgram() {
      try {
        program = createProgram(gl, vertEditor.value, fragEditor.value);
        gl.useProgram(program);
        posLoc = gl.getAttribLocation(program, "aPosition");
        colorLoc = gl.getAttribLocation(program, "aColor");
        timeLoc = gl.getUniformLocation(program, "uTime");
        uMVM = gl.getUniformLocation(program, "uModelViewMatrix");
        uPM = gl.getUniformLocation(program, "uProjectionMatrix");
        uMTM = gl.getUniformLocation(program, "uModelTransformationMatrix");
      } catch (e) { console.error(e); }
    }
    initShaderProgram();
    vertEditor.onkeyup = initShaderProgram;
    fragEditor.onkeyup = initShaderProgram;

    // Mouse and keyboard interactions
    let mouseDown = false, lastX, lastY, cubeRotX = 0, cubeRotY = 0;
    let camX = 0, camY = 0, camZ = -6;

    canvas.addEventListener('mousedown', e => { mouseDown = true; lastX = e.clientX; lastY = e.clientY; });
    canvas.addEventListener('mouseup', () => mouseDown = false);
    canvas.addEventListener('mousemove', e => {
      if (!mouseDown) return;
      let dx = e.clientX - lastX;
      let dy = e.clientY - lastY;
      cubeRotY += dx * 0.01;
      cubeRotX += dy * 0.01;
      lastX = e.clientX; lastY = e.clientY;
    });

    document.addEventListener('keydown', e => {
      const step = 0.2;
      switch (e.key) {
        case 'ArrowUp': camY -= step; break;
        case 'ArrowDown': camY += step; break;
        case 'ArrowLeft': camX += step; break;
        case 'ArrowRight': camX -= step; break;
        case 'w': camZ += step; break;
        case 's': camZ -= step; break;
      }
    });

    let fov = Math.PI / 4, aspect = canvas.width / canvas.height, zNear = 0.1, zFar = 100;
    let f = 1 / Math.tan(fov / 2);
    let proj = new Float32Array([
      f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (zFar + zNear) / (zNear - zFar), -1, 0, 0, (2 * zFar * zNear) / (zNear - zFar), 0
    ]);

    let startTime = Date.now();

    function render() {
      gl.enable(gl.DEPTH_TEST);
      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // rotation matrices
      let cx = Math.cos(cubeRotY), sx = Math.sin(cubeRotY);
      let cy = Math.cos(cubeRotX), sy = Math.sin(cubeRotX);
      let rotX = [1, 0, 0, 0, 0, cy, sy, 0, 0, -sy, cy, 0, 0, 0, 0, 1];
      let rotY = [cx, 0, -sx, 0, 0, 1, 0, 0, sx, 0, cx, 0, 0, 0, 0, 1];
      let cubeRotation = multiplyMat4(rotY, rotX);

      // init model-view matrix as identity matrix
      let modelViewMatrix = mat4Identity();
      // camera translation
      modelViewMatrix = mat4Translate(modelViewMatrix, [camX, camY, camZ]);

      //delta time in ms
      let deltaTime = Date.now() - startTime;
      
      gl.uniformMatrix4fv(uPM, false, proj);
      gl.uniformMatrix4fv(uMVM, false, modelViewMatrix);

      for (const shape of currentShapes) {
        //set time in seconds, apply randomness for each shape
        gl.uniform1f(timeLoc, (deltaTime/1000.0) * shape.timeSpeed + shape.timeOffset);

        const motionSetLoc = gl.getUniformLocation(program, "uMotionSet");
        const motionChangeLoc = gl.getUniformLocation(program, "uMotionChange");
        gl.uniform3fv(motionSetLoc, shape.motionSet);
        gl.uniform1f(motionChangeLoc, shape.motionChange);

        modelTransformationMatrix = multiplyMat4(cubeRotation, shape.modelMatrix);
        gl.uniformMatrix4fv(uMTM, false, modelTransformationMatrix);
        initBuffers(shape.vertices, shape.indices, shape.colors);

        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, nbo);
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);

        // draw the object by the index order
        gl.drawElements(gl.TRIANGLES, shape.indices.length, gl.UNSIGNED_SHORT, 0);
      }
    }

    // Initialize when page loads
    window.onload = function () {
      document.getElementById("cubeBtn").addEventListener("click", () => addShape("cube"));
      document.getElementById("pyramidBtn").addEventListener("click", () => addShape("pyramid"));
      document.getElementById("sphereBtn").addEventListener("click", () => addShape("sphere"));
      document.getElementById("deleteBtn").addEventListener("click", () => deleteLastShape());
      document.getElementById("clearBtn").addEventListener("click", () => {
        currentShapes = [];
      });

      setInterval(render, 30);
    }

  </script>
</body>

</html>